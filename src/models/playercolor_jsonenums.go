// Code generated by jsonenums -type=PlayerColor; DO NOT EDIT.

package models

import (
	"encoding/json"
	"fmt"
)

var (
	_PlayerColorNameToValue = map[string]PlayerColor{
		"Teal":   Teal,
		"Blue":   Blue,
		"Amber":  Amber,
		"Red":    Red,
		"Lime":   Lime,
		"Purple": Purple,
		"Pink":   Pink,
	}

	_PlayerColorValueToName = map[PlayerColor]string{
		Teal:   "Teal",
		Blue:   "Blue",
		Amber:  "Amber",
		Red:    "Red",
		Lime:   "Lime",
		Purple: "Purple",
		Pink:   "Pink",
	}
)

func init() {
	var v PlayerColor
	if _, ok := interface{}(v).(fmt.Stringer); ok {
		_PlayerColorNameToValue = map[string]PlayerColor{
			interface{}(Teal).(fmt.Stringer).String():   Teal,
			interface{}(Blue).(fmt.Stringer).String():   Blue,
			interface{}(Amber).(fmt.Stringer).String():  Amber,
			interface{}(Red).(fmt.Stringer).String():    Red,
			interface{}(Lime).(fmt.Stringer).String():   Lime,
			interface{}(Purple).(fmt.Stringer).String(): Purple,
			interface{}(Pink).(fmt.Stringer).String():   Pink,
		}
	}
}

// MarshalJSON is generated so PlayerColor satisfies json.Marshaler.
func (r PlayerColor) MarshalJSON() ([]byte, error) {
	if s, ok := interface{}(r).(fmt.Stringer); ok {
		return json.Marshal(s.String())
	}
	s, ok := _PlayerColorValueToName[r]
	if !ok {
		return nil, fmt.Errorf("invalid PlayerColor: %d", r)
	}
	return json.Marshal(s)
}

// UnmarshalJSON is generated so PlayerColor satisfies json.Unmarshaler.
func (r *PlayerColor) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("PlayerColor should be a string, got %s", data)
	}
	v, ok := _PlayerColorNameToValue[s]
	if !ok {
		return fmt.Errorf("invalid PlayerColor %q", s)
	}
	*r = v
	return nil
}
